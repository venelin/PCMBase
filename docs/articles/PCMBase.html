<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Getting Started with the PCMBase R-package • PCMBase</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Getting Started with the PCMBase R-package">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129563006-3"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129563006-3');
</script>
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">PCMBase</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.2.10</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/PCMBase.html">Get started</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/PCMParam.html">The PCMBase Parametrization API</a>
    </li>
    <li>
      <a href="../articles/PCMCreateModel.html">Defining a New Model in the PCMBase Framework</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Getting Started with the PCMBase R-package</h1>
                        <h4 class="author">Venelin Mitov</h4>
            
            <h4 class="date">2019-04-08</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/venelin/PCMBase/blob/master/vignettes/PCMBase.Rmd"><code>vignettes/PCMBase.Rmd</code></a></small>
      <div class="hidden name"><code>PCMBase.Rmd</code></div>

    </div>

    
    
<div id="data" class="section level1">
<h1 class="hasAnchor">
<a href="#data" class="anchor"></a>Data</h1>
<p>The input data for the phylogenetic comparative methods covered in the PCMBase package consists of a phylogenetic tree of <span class="math inline">\(N\)</span> tips and a <span class="math inline">\(k\times N\)</span> matrix, <span class="math inline">\(X\)</span> of observed trait-values, where <span class="math inline">\(k\)</span> is the number of traits. The matrix <span class="math inline">\(X\)</span> can contain <code>NA</code>s corresponding to missing measurements and <code>NaN</code>’s corresponding to non-existing traits for some of the tips.</p>
</div>
<div id="models" class="section level1">
<h1 class="hasAnchor">
<a href="#models" class="anchor"></a>Models</h1>
<p>Given a number of traits <span class="math inline">\(k\)</span>, a <em>model</em> is defined as a set of parameters with dimiensionality possibly depending on <span class="math inline">\(k\)</span> and a rule stating how these parameters are used to calculate the model likelihood for an observed tree and data and/or to simulate data along a tree. Often, we use the term <em>model type</em> to denote a family of models sharing the same rule.</p>
<div id="the-mathcalg_linv-family-of-models" class="section level2">
<h2 class="hasAnchor">
<a href="#the-mathcalg_linv-family-of-models" class="anchor"></a>The <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family of models</h2>
<p>Currently, PCMBase supports Gaussian model types from the so called <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family <span class="citation">(Mitov et al. 2018)</span>. Specifically, these are models representing branching stochastic processes and satisfying the following two conditions <span class="citation">(Mitov et al. 2018)</span>:</p>
<ol style="list-style-type: decimal">
<li>after a branching point on the tree the traits evolve independently in the two descending lineages,</li>
<li>
<p>the distribution of the trait <span class="math inline">\(\vec{X}\)</span>, at time <span class="math inline">\(t\)</span> conditional on the value at time <span class="math inline">\(s &lt; t\)</span> is Gaussian with the mean and variance satisfying</p>
<p>2.a The expectation depends linearly on the ancestral trait value, i.e. <span class="math inline">\(\text{E}\big[{\vec{X}(t) \vert \vec{X}(s)}\big] = \vec{\omega}_{s,t} + \mathbf{\Phi}_{s,t} \vec{X}(s)\)</span>;</p>
<p>2.b The variance is invariant (does not depend on) with respect to the ancestral trait, i.e. <span class="math inline">\(\text{V}\big[{\vec{X}(t) \vert \vec{X}(s)}\big] = \mathbf{V}_{s,t}\)</span>,</p>
</li>
</ol>
<p>where <span class="math inline">\(\vec{\omega}\)</span> and the matrices <span class="math inline">\(\mathbf{\Phi}\)</span>, <span class="math inline">\(\mathbf{V}\)</span> may depend on <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> but do not depend on the previous trajectory of the trait <span class="math inline">\(\vec{X}(\cdot)\)</span>.</p>
</div>
<div id="example-ornstein-uhlenbeck-model-types" class="section level2">
<h2 class="hasAnchor">
<a href="#example-ornstein-uhlenbeck-model-types" class="anchor"></a>Example: Ornstein-Uhlenbeck model types</h2>
As an example, let’s consider a model representing a <span class="math inline">\(k\)</span>-variate Ornstein-Uhlenbec branching stochastic process. This is defined by the following stochastic differential equation:
<span class="math display">\[\begin{equation}\label{eq:mammals:OUprocess}
d\vec{X}(t)=\mathbf{H}\big(\vec{\theta}-\vec{X}(t)\big)dt+\mathbf{\mathbf{\Sigma}}_{\chi} dW(t). 
\end{equation}\]</span>
<p>In the above equation, <span class="math inline">\(\vec{X}(t)\)</span> is a <span class="math inline">\(k\)</span>-dimensional real vector, <span class="math inline">\(\mathbf{H}\)</span> is a <span class="math inline">\(k\times k\)</span>-dimensional eigen-decomposable real matrix, <span class="math inline">\(\vec{\theta}\)</span> is a <span class="math inline">\(k\)</span>-dimensional real vector, <span class="math inline">\(\mathbf{\Sigma}_{\chi}\)</span> is a <span class="math inline">\(k\times k\)</span>-dimensional real positive definite matrix and <span class="math inline">\(W(t)\)</span> denotes the <span class="math inline">\(k\)</span>-dimensional standard Wiener process.</p>
<p>Biologically, <span class="math inline">\(\vec{X}(t)\)</span> denotes the mean values of <span class="math inline">\(k\)</span> continuous traits in a species at a time <span class="math inline">\(t\)</span> from the root, the parameter <span class="math inline">\(\mathbf{\Sigma}=\mathbf{\Sigma}_{\chi}\mathbf{\Sigma}_{\chi}^T\)</span> defines the magnitude and shape of the momentary fluctuations in the mean vector due to genetic drift, the matrix <span class="math inline">\(\mathbf{H}\)</span> and the vector <span class="math inline">\(\vec{\theta}\)</span> specify the trajectory of the population mean through time. When <span class="math inline">\(\mathbf{H}\)</span> is the zero matrix, the process is equivalent to a Brownian motion process and the parameter <span class="math inline">\(\vec{\theta}\)</span> is irrelevant. When <span class="math inline">\(\mathbf{H}\)</span> has strictly positive eigenvalues, the population mean converges in the long term towards <span class="math inline">\(\vec{\theta}\)</span>, although the trajectory of this convergence can be complex.</p>
<p>So, the OU-model defines the following set of parameters:</p>
<ul>
<li>
<span class="math inline">\(\vec{X}_{0}\)</span> (coded <code>X0</code>) : a <span class="math inline">\(k\)</span>-vector of initial values;</li>
<li>
<span class="math inline">\(\mathbf{H}\)</span> (coded <code>H</code>) : a <span class="math inline">\(k\times k\)</span> matrix denoting the selection strength of the process;</li>
<li>
<span class="math inline">\(\vec{\theta}\)</span> (coded <code>Theta</code>) : a <span class="math inline">\(k\)</span>-vector of long-term optimal trait values;</li>
<li>
<span class="math inline">\(\mathbf{\Sigma}_{\chi}\)</span> : (coded <code>Sigma_x</code>) : a <span class="math inline">\(k\times k\)</span> matrix denoting the Choleski factor or the stochastic drift variance-covariances; <!-- - $\mathbf{\Sigma}_{e,\chi}$ (coded `Sigmae_x`) : a $k\times k$ matrix denoting the Choleski factor of the non-genetic (non-heritable) variance covariance; -->
</li>
</ul>
The rule defining how the parameters of the OU-model are used to calculate the model likelihood and to simulate data consists in the definition of the functions <span class="math inline">\(\vec{\omega}\)</span> and matrices <span class="math inline">\(\mathbf{\Phi}\)</span>, <span class="math inline">\(\mathbf{V}\)</span> <span class="citation">(Mitov et al. 2018)</span>:
<span class="math display">\[\begin{equation}\label{eq:mammals:omegaPhiVOU}
\begin{array}{l}
\vec{\omega}_{s,t}=\bigg(\mathbf{I}-\text{Exp}\big(-(t-s)\mathbf{H}\big)\bigg)\vec{\theta} \\
\mathbf{\Phi}_{s,t}=\text{Exp}(-(t-s)\mathbf{H}) \\
\mathbf{V}_{s,t}=\int_{0}^{t-s}\text{Exp}(-v\mathbf{H})(\mathbf{\Sigma}_{\chi}\mathbf{\Sigma}_{\chi}^T)\text{Exp}(-v\mathbf{H}^T)dv
\end{array}
\end{equation}\]</span>
<p>Together, <span class="math inline">\(\vec{X}_{0}\)</span>, <span class="math inline">\(\vec{\omega}\)</span>, <span class="math inline">\(\mathbf{\Phi}\)</span>, <span class="math inline">\(\mathbf{V}\)</span> and the tree define a <span class="math inline">\(kN\)</span>-variate Gaussian distribution for the vector of trait values at the tips. This is the defining property of all Gaussian phylogenetic models. Hence, calculating the model likelihood is equivalent to calculating the density of this Gaussian distribution at observed trait values, and simulating data under the model is equivalent to drawing a random sample from this distribution. The functions <code><a href="../reference/PCMMean.html">PCMMean()</a></code> and <code><a href="../reference/PCMVar.html">PCMVar()</a></code> allow to calculate the mean <span class="math inline">\(kN\)</span>-vector and the <span class="math inline">\(kN\times kN\)</span> variance covariance matrix of this distribution. This can be useful, in particular, to compare two models by calculating a distance metric such as the Mahalanobis distance, or the Bhattacharyya distance. However, for big <span class="math inline">\(k\)</span> and/or <span class="math inline">\(N\)</span>, it is inefficient to use these functions in combination with a general purpose multivariate normal implementation (e.g. the <code><a href="https://www.rdocumentation.org/packages/mvtnorm/topics/Mvnorm">mvtnorm::dmvnorm</a></code> and <code><a href="https://www.rdocumentation.org/packages/mvtnorm/topics/Mvnorm">mvtnorm::rmvnorm</a></code>), to calculate the likelihood or simulate data assuming an OU model. The main purpose of PCMBase package is to provide a generic and computationally efficient way to perform these two operations.</p>
</div>
<div id="groups-of-model-types" class="section level2">
<h2 class="hasAnchor">
<a href="#groups-of-model-types" class="anchor"></a>Groups of model types</h2>
<p>It is convenient to group model types into smaller subsets with named elements. This allows to use simple names, such as letters, as aliases for otherwise very long model type names. For example, the PCMBase package defines a subset of six so called “default model types”, which are commonly used in macroevolutionary studies. These are model types based on parameterizations of the <span class="math inline">\(k\)</span>-variate Ornstein-Uhlenbeck (OU) process. All of these six models restrict <span class="math inline">\(\mathbf{H}\)</span> to have non-negative eigenvalues - a negative eigenvalue of <span class="math inline">\(\mathbf{H}\)</span> transforms the process into repulsion with respect to <span class="math inline">\(\vec{\theta}\)</span>, which, while biologically plausible, is not identifiable in a ultrametric tree. The six default models are defined as follows:</p>
<ul>
<li>
<span class="math inline">\(BM_{A}\)</span> (<span class="math inline">\(\mathbf{H}=0\)</span>, diagonal <span class="math inline">\(\mathbf{\Sigma}\)</span>): BM, uncorrelated traits;</li>
<li>
<span class="math inline">\(BM_{B}\)</span> (<span class="math inline">\(\mathbf{H}=0\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): BM, correlated traits;</li>
<li>
<span class="math inline">\(OU_{C}\)</span> (diagonal <span class="math inline">\(\mathbf{H}\)</span>, diagonal <span class="math inline">\(\mathbf{\Sigma}\)</span>): OU, uncorrelated traits;</li>
<li>
<span class="math inline">\(OU_{D}\)</span> (diagonal <span class="math inline">\(\mathbf{H}\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): OU, correlated traits, but simple (diagonal) selection strength matrix;</li>
<li>
<span class="math inline">\(OU_{E}\)</span> (symmetric <span class="math inline">\(\mathbf{H}\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): An OU with non-diagonal symmetric <span class="math inline">\(\mathbf{H}\)</span> and non-diagonal symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>;</li>
<li>
<span class="math inline">\(OU_{F}\)</span> (asymmetric <span class="math inline">\(\mathbf{H}\)</span>, symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>): An OU with non-diagonal asymmetric <span class="math inline">\(\mathbf{H}\)</span> and non-diagonal symmetric <span class="math inline">\(\mathbf{\Sigma}\)</span>;</li>
</ul>
<p>Calling the function <code><a href="../reference/PCMDefaultModelTypes.html">PCMDefaultModelTypes()</a></code> returns a named vector of the technical class-names for these six models:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># scroll to the right in the following listing to see the full model type names </span>
<span class="co"># and their corresponding alias:</span>
<span class="kw"><a href="../reference/PCMDefaultModelTypes.html">PCMDefaultModelTypes</a></span>()</code></pre></div>
<pre><code>##                                                                                                                                                                                A 
##                                                                                                      "BM__Global_X0__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                B 
##                                                                                   "BM__Global_X0__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                C 
##                                       "OU__Global_X0__Schur_Diagonal_WithNonNegativeDiagonal_Transformable_H__Theta__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                D 
##                    "OU__Global_X0__Schur_Diagonal_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                E 
## "OU__Global_X0__Schur_UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                F 
##                             "OU__Global_X0__Schur_WithNonNegativeDiagonal_Transformable_H__Theta__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                G 
##                                                                                       "BM_drift__Global_X0__h_drift__Diagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x" 
##                                                                                                                                                                                H 
##                                                                    "BM_drift__Global_X0__h_drift__UpperTriangularWithDiagonal_WithNonNegativeDiagonal_Sigma_x__Omitted_Sigmae_x"</code></pre>
<p>The PCMBase package comes with numerous other predefined model types. At present, all these are members of the <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family. A list of these model types is returned from calling the function <code><a href="../reference/PCMModels.html">PCMModels()</a></code>.</p>
<p>For each model type, it is possible to check how the conditional distribution of <span class="math inline">\(\vec{X}\)</span> at the end of a time interval of length <span class="math inline">\(t\)</span> is defined from an ancestral value <span class="math inline">\(X_{0}\)</span>. In particular, for <span class="math inline">\(\mathcal{G}_{LInv}\)</span> models, this is the definition of the functions <span class="math inline">\(\vec{\omega}\)</span>, <span class="math inline">\(\mathbf{\Phi}\)</span> and <span class="math inline">\(\mathbf{V}\)</span>. For example,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/PCMFindMethod.html">PCMFindMethod</a></span>(<span class="kw"><a href="../reference/PCMDefaultModelTypes.html">PCMDefaultModelTypes</a></span>()[<span class="st">"A"</span>], <span class="st">"PCMCond"</span>)</code></pre></div>
<pre><code>## function (tree, model, r = 1, metaI = PCMInfo(NULL, tree, model, 
##     verbose = verbose), verbose = FALSE) 
## {
##     Sigma_x &lt;- if (is.Global(model$Sigma_x)) 
##         as.matrix(model$Sigma_x)
##     else as.matrix(model$Sigma_x[, , r])
##     Sigma &lt;- Sigma_x %*% t(Sigma_x)
##     if (!is.null(model$Sigmae_x)) {
##         Sigmae_x &lt;- if (is.Global(model$Sigmae_x)) 
##             as.matrix(model$Sigmae_x)
##         else as.matrix(model$Sigmae_x[, , r])
##         Sigmae &lt;- Sigmae_x %*% t(Sigmae_x)
##     }
##     else {
##         Sigmae &lt;- NULL
##     }
##     V &lt;- PCMCondVOU(matrix(0, nrow(Sigma), ncol(Sigma)), Sigma, 
##         Sigmae)
##     omega &lt;- function(t, edgeIndex, metaI) {
##         rep(0, nrow(Sigma))
##     }
##     Phi &lt;- function(t, edgeIndex, metaI, e_Ht = NULL) {
##         diag(nrow(Sigma))
##     }
##     list(omega = omega, Phi = Phi, V = V)
## }
## &lt;bytecode: 0x7fc1a23c8560&gt;
## &lt;environment: namespace:PCMBase&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># The complex maths is implemented in the function PCMCondVOU. You can see its </span>
<span class="co"># R-code by typing :</span>
<span class="co"># PCMBase::PCMCondVOU</span></code></pre></div>
</div>
<div id="creating-pcm-objects" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-pcm-objects" class="anchor"></a>Creating PCM objects</h2>
<p>In the computer memory, models are represented by S3 objects, i.e. ordinary R-lists with a class attribute. The base S3 class of all models is called <code>"PCM"</code>, which is inherited by more specific model-classes. Let us create a BM PCM for two traits:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelBM &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCM.html">PCM</a></span>(<span class="dt">model =</span> <span class="st">"BM"</span>, <span class="dt">k =</span> <span class="dv">2</span>)</code></pre></div>
<p>Printing the model object shows a short verbal description, the S3-class, the number of traits, k, the number of numerical parameters of the model, p, the model regimes and the current values of the parameters for each regime (more on regimes in the next sub-section):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelBM</code></pre></div>
<pre><code>## Brownian motion model
## S3 class: BM, GaussianPCM, PCM; k=2; p=8; regimes: 1. Parameters/sub-models:
## X0 (VectorParameter, _Global, numeric; trait values at the root):
## [1] 0 0
## Sigma_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; Choleski factor of the unit-time variance rate):
## , , 1
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## Sigmae_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; Choleski factor of the non-heritable variance or the variance of the measurement error):
## , , 1
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## </code></pre>
<p>One may wonder why in the above description, p = 8 instead of 10 (see also <code><a href="../reference/PCMParamCount.html">?PCMParamCount</a></code>). The reason is that both, the matrix Sigma and the matrix Sigmae, are symmetric matrices and their matching off-diagonal elements are counted only one time.</p>
</div>
<div id="model-regimes" class="section level2">
<h2 class="hasAnchor">
<a href="#model-regimes" class="anchor"></a>Model regimes</h2>
<p>Model <em>regimes</em> are different models associated with different parts of the phylogenetic tree. This is a powerful concept allowing to model different evolutionary modes on different lineages on the tree. Let us create a 2-trait BM model with two regimes called a and b:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelBM.ab &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCM.html">PCM</a></span>(<span class="st">"BM"</span>, <span class="dt">k =</span> <span class="dv">2</span>, <span class="dt">regimes =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">"a"</span>, <span class="st">"b"</span>))
modelBM.ab</code></pre></div>
<pre><code>## Brownian motion model
## S3 class: BM, GaussianPCM, PCM; k=2; p=14; regimes: a, b. Parameters/sub-models:
## X0 (VectorParameter, _Global, numeric; trait values at the root):
## [1] 0 0
## Sigma_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; Choleski factor of the unit-time variance rate):
## , , a
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## , , b
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## Sigmae_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; Choleski factor of the non-heritable variance or the variance of the measurement error):
## , , a
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## , , b
## 
##      [,1] [,2]
## [1,]    0    0
## [2,]    0    0
## 
## </code></pre>
<p>Now, we can set some different values for the parameters of the model we’ve just created. First, let us specify an initial value vector different from the default 0-vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">modelBM.ab<span class="op">$</span>X0[] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">5</span>, <span class="dv">2</span>)</code></pre></div>
<p>X0 is defined as a parameter with S3 class <code><a href="https://www.rdocumentation.org/packages/base/topics/class">class(modelBM.ab$X0)</a></code>. This specifies that <code>X0</code> is global vector parameter shared by all model regimes. This is also the reason, why the number of parameters is not the double of the number of parameters in the first model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/PCMParamCount.html">PCMParamCount</a></span>(modelBM)</code></pre></div>
<pre><code>## [1] 8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/PCMParamCount.html">PCMParamCount</a></span>(modelBM.ab)</code></pre></div>
<pre><code>## [1] 14</code></pre>
<p>The other parameters, Sigma_x and Sigmae_x are local for each regime:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># in regime 'a' the traits evolve according to two independent BM processes (starting from the global vecto X0).</span>
modelBM.ab<span class="op">$</span>Sigma_x[,, <span class="st">"a"</span>] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">rbind</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="fl">1.6</span>, <span class="dv">0</span>),
                                  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">0</span>, <span class="fl">2.4</span>))
modelBM.ab<span class="op">$</span>Sigmae_x[,, <span class="st">"a"</span>] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">rbind</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(.<span class="dv">1</span>, <span class="dv">0</span>),
                                   <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">0</span>, .<span class="dv">4</span>))
<span class="co"># in regime 'b' there is a correlation between the traits</span>
modelBM.ab<span class="op">$</span>Sigma_x[,, <span class="st">"b"</span>] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">rbind</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="fl">1.6</span>, .<span class="dv">8</span>),
                                  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(.<span class="dv">8</span>, <span class="fl">2.4</span>))
modelBM.ab<span class="op">$</span>Sigmae_x[,, <span class="st">"b"</span>] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cbind">rbind</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(.<span class="dv">1</span>, <span class="dv">0</span>),
                                   <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">0</span>, .<span class="dv">4</span>))</code></pre></div>
<p>The above way of setting values for model parameters, while human readable, is not handy during model fitting procedures, such as likelihood maximization. Thus, there is another way to set (or get) the model parameter values from a numerical vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">param &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/double">double</a></span>(<span class="kw"><a href="../reference/PCMParamCount.html">PCMParamCount</a></span>(modelBM.ab))

<span class="co"># load the current model parameters into param</span>
<span class="kw"><a href="../reference/PCMParamLoadOrStore.html">PCMParamLoadOrStore</a></span>(modelBM.ab, param, <span class="dt">offset=</span><span class="dv">0</span>, <span class="dt">load=</span><span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] 14</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(param)</code></pre></div>
<pre><code>##  [1] 5.0 2.0 1.6 0.0 2.4 1.6 0.8 2.4 0.1 0.0 0.4 0.1 0.0 0.4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># modify slightly the model parameters</span>
param2 &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/jitter">jitter</a></span>(param)

<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(param2)</code></pre></div>
<pre><code>##  [1]  4.984402282  1.992651044  1.618906926 -0.009241985  2.386414173
##  [6]  1.583571380  0.803764246  2.410107630  0.082857763  0.009688693
## [11]  0.419981785  0.112986828 -0.005950268  0.387270594</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># set the new parameter vector</span>
<span class="kw"><a href="../reference/PCMParamLoadOrStore.html">PCMParamLoadOrStore</a></span>(modelBM.ab, param2, <span class="dt">offset =</span> <span class="dv">0</span>, <span class="dt">load=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] 14</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(modelBM.ab)</code></pre></div>
<pre><code>## Brownian motion model
## S3 class: BM, GaussianPCM, PCM; k=2; p=14; regimes: a, b. Parameters/sub-models:
## X0 (VectorParameter, _Global, numeric; trait values at the root):
## [1] 4.984402 1.992651
## Sigma_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; Choleski factor of the unit-time variance rate):
## , , a
## 
##          [,1]         [,2]
## [1,] 1.618907 -0.009241985
## [2,] 0.000000  2.386414173
## 
## , , b
## 
##          [,1]      [,2]
## [1,] 1.583571 0.8037642
## [2,] 0.800000 2.4101076
## 
## Sigmae_x (MatrixParameter, _UpperTriangularWithDiagonal, _WithNonNegativeDiagonal; Choleski factor of the non-heritable variance or the variance of the measurement error):
## , , a
## 
##            [,1]        [,2]
## [1,] 0.08285776 0.009688693
## [2,] 0.00000000 0.419981785
## 
## , , b
## 
##           [,1]         [,2]
## [1,] 0.1129868 -0.005950268
## [2,] 0.0000000  0.387270594
## 
## </code></pre>
</div>
</div>
<div id="simulating-data-on-a-phylogenetic-tree" class="section level1">
<h1 class="hasAnchor">
<a href="#simulating-data-on-a-phylogenetic-tree" class="anchor"></a>Simulating data on a phylogenetic tree</h1>
<p>The first functionality of the PCMBase package is to provide an easy way to simulate multiple trait data on a tree under a given (possibly multiple regime) PCM.</p>
<p>For this example, first we simulate a birth death tree with two parts “a” and “b” using the <code>phytools</code> R-package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># make results reproducible</span>
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Random">set.seed</a></span>(<span class="dv">2</span>, <span class="dt">kind =</span> <span class="st">"Mersenne-Twister"</span>, <span class="dt">normal.kind =</span> <span class="st">"Inversion"</span>)

<span class="co"># number of regimes</span>
R &lt;-<span class="st"> </span><span class="dv">2</span>

<span class="co"># number of extant tips</span>
N &lt;-<span class="st"> </span><span class="dv">100</span>

tree.a &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCMTree.html">PCMTree</a></span>(<span class="kw">rtree</span>(<span class="dt">n=</span>N))
<span class="kw"><a href="../reference/PCMTreeSetLabels.html">PCMTreeSetLabels</a></span>(tree.a)
<span class="kw"><a href="../reference/PCMTreeSetPartRegimes.html">PCMTreeSetPartRegimes</a></span>(tree.a, <span class="dt">part.regime =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">`</span><span class="dt">101</span><span class="st">`</span> =<span class="st"> "a"</span>), <span class="dt">setPartition =</span> <span class="ot">TRUE</span>)

lstDesc &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCMTreeListDescendants.html">PCMTreeListDescendants</a></span>(tree.a)
splitNode &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/names">names</a></span>(lstDesc)[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/lapply">sapply</a></span>(lstDesc, length) <span class="op">&gt;</span><span class="st"> </span>N<span class="op">/</span><span class="dv">2</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/lapply">sapply</a></span>(lstDesc, length) <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>N<span class="op">/</span><span class="dv">3</span>)][<span class="dv">1</span>]

tree.ab &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCMTreeInsertSingletons.html">PCMTreeInsertSingletons</a></span>(
  tree.a, <span class="dt">nodes =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/integer">as.integer</a></span>(splitNode), 
  <span class="dt">positions =</span> <span class="kw"><a href="../reference/PCMTreeGetBranchLength.html">PCMTreeGetBranchLength</a></span>(tree.a, <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/integer">as.integer</a></span>(splitNode))<span class="op">/</span><span class="dv">2</span>)
<span class="kw"><a href="../reference/PCMTreeSetPartRegimes.html">PCMTreeSetPartRegimes</a></span>(
  tree.ab,
  <span class="dt">part.regime =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/structure">structure</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">"a"</span>, <span class="st">"b"</span>), <span class="dt">names =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/character">as.character</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(N<span class="op">+</span><span class="dv">1</span>, splitNode))), 
  <span class="dt">setPartition =</span> <span class="ot">TRUE</span>)

palette &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCMColorPalette.html">PCMColorPalette</a></span>(<span class="dv">2</span>, <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">"a"</span>, <span class="st">"b"</span>))
<span class="kw"><a href="../reference/PCMTreePlot.html">PCMTreePlot</a></span>(tree.ab) <span class="op">+</span><span class="st"> </span>ggtree<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/ggtree/topics/geom_nodelab">geom_nodelab</a></span>(<span class="dt">size =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="PCMBase_files/figure-html/unnamed-chunk-10-1.png" width="700"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># plot(tree.ab, show.tip.label=FALSE, </span>
<span class="co">#      edge.color = palette[PCMTreeGetRegimesForEdges(tree.ab)])</span></code></pre></div>
<p>Now we can simulate data on the tree using the modelBM.ab$X0 as a starting value:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">traits &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCMSim.html">PCMSim</a></span>(tree.ab, modelBM.ab, modelBM.ab<span class="op">$</span>X0)</code></pre></div>
</div>
<div id="calculating-likelihoods" class="section level1">
<h1 class="hasAnchor">
<a href="#calculating-likelihoods" class="anchor"></a>Calculating likelihoods</h1>
<p>Calculating a model likelihood for a given tree and data is the other key functionality of the PCMBase package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/PCMLik.html">PCMLik</a></span>(traits, tree.ab, modelBM.ab)</code></pre></div>
<pre><code>## [1] -409.1877
## attr(,"X0")
## [1] 4.984402 1.992651
## attr(,"class")
## [1] "VectorParameter" "_Global"         "numeric"        
## attr(,"description")
## [1] "trait values at the root"</code></pre>
<p>For faster and repeated likelihood evaluation, I recommend creating a likelihood function for a given data, tree and model object. Passing this function object to <code>optim</code> would save the need for pre-processing the data and tree at every likelihood evaluation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># a function of a numerical parameter vector:</span>
likFun &lt;-<span class="st"> </span><span class="kw"><a href="../reference/PCMCreateLikelihood.html">PCMCreateLikelihood</a></span>(traits, tree.ab, modelBM.ab)

<span class="kw">likFun</span>(param2)</code></pre></div>
<pre><code>## [1] -409.1877
## attr(,"X0")
## [1] 4.984402 1.992651
## attr(,"class")
## [1] "VectorParameter" "_Global"         "numeric"        
## attr(,"description")
## [1] "trait values at the root"</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-Mitov:2018fl">
<p>Mitov, Venelin, Krzysztof Bartoszek, Georgios Asimomitis, and Tanja Stadler. 2018. “Fast likelihood evaluation for multivariate phylogenetic comparative methods: the PCMBase R package.” <em>arXiv.org</em>, September, arXiv:1809.09014. <a href="http://arxiv.org/abs/1809.09014" class="uri">http://arxiv.org/abs/1809.09014</a>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#data">Data</a></li>
      <li>
<a href="#models">Models</a><ul class="nav nav-pills nav-stacked">
<li><a href="#the-mathcalg_linv-family-of-models">The <span class="math inline">\(\mathcal{G}_{LInv}\)</span>-family of models</a></li>
      <li><a href="#example-ornstein-uhlenbeck-model-types">Example: Ornstein-Uhlenbeck model types</a></li>
      <li><a href="#groups-of-model-types">Groups of model types</a></li>
      <li><a href="#creating-pcm-objects">Creating PCM objects</a></li>
      <li><a href="#model-regimes">Model regimes</a></li>
      </ul>
</li>
      <li><a href="#simulating-data-on-a-phylogenetic-tree">Simulating data on a phylogenetic tree</a></li>
      <li><a href="#calculating-likelihoods">Calculating likelihoods</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Venelin Mitov.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
